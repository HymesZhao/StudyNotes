- [**1、课程整体内容概述**](#1课程整体内容概述)
  - [**1.1、Java语言概述**](#11java语言概述)
    - [**1.1.1、基础常识**](#111基础常识)
    - [**1.1.2.计算机语言的发展迭代史**](#112计算机语言的发展迭代史)
    - [**1.1.3.Java语言版本迭代概述**](#113java语言版本迭代概述)
    - [**1.1.4.Java语言应用的领域：**](#114java语言应用的领域)
    - [**1.1.5.Java语言的特点**](#115java语言的特点)
  - [**1.2、开发环境搭建**](#12开发环境搭建)
    - [**1.2.1 JDK、JRE、JVM的关系**](#121-jdkjrejvm的关系)
    - [**1.2.2 JDK的下载、安装**](#122-jdk的下载安装)
    - [**1.2.3 path环境变量的配置**](#123-path环境变量的配置)
  - [**1.3、第一个Java程序**](#13第一个java程序)
    - [**1.3.1.开发体验——HelloWorld**](#131开发体验helloworld)
    - [**1.3.2.常见问题的解决**](#132常见问题的解决)
    - [**1.3.3.总结第一个程序**](#133总结第一个程序)
  - [**1.4、注释与API文档等**](#14注释与api文档等)
    - [**1.4.1.注释:Comment**](#141注释comment)
    - [**1.4.2.Java API 文档：**](#142java-api-文档)
    - [**1.4.3.良好的编程风格**](#143良好的编程风格)
- [**2、基础语法**](#2基础语法)
  - [**2.1、关键字与标识符**](#21关键字与标识符)
    - [**2.1.1.java关键字的使用**](#211java关键字的使用)
    - [**2.1.2.保留字：**](#212保留字)
    - [**2.1.3.标识符的使用**](#213标识符的使用)
  - [**2.2、变量的使用(重点)**](#22变量的使用重点)
    - [**2.2.1.变量的分类**](#221变量的分类)
    - [2.2.2.定义变量的格式：**](#222定义变量的格式)
    - [**2.2.3.变量使用的注意点：**](#223变量使用的注意点)
    - [**2.2.4.基本数据类型变量间运算规则**](#224基本数据类型变量间运算规则)
    - [**2.2.5 涉及到的基本数据类型：**](#225-涉及到的基本数据类型)
  - [**2.3、进制(了解)**](#23进制了解)
    - [**2.3.1.编程中涉及的进制及表示方式：**](#231编程中涉及的进制及表示方式)
    - [**2.3.2.二进制的使用说明：**](#232二进制的使用说明)
  - [**2.4、运算符**](#24运算符)
    - [**2.4.1.算术运算符：**](#241算术运算符)
    - [**2.4.2.赋值运算符**](#242赋值运算符)
    - [**2.4.3.比较运算符（关系运算符）**](#243比较运算符关系运算符)
    - [**2.4.4.逻辑运算符**](#244逻辑运算符)
    - [**2.4.5.位运算符：**](#245位运算符)
    - [**2.4.6.三元运算符**](#246三元运算符)
  - [**2.5.流程控制**](#25流程控制)
    - [**2.5.1分支结构**](#251分支结构)
      - [2.5.1.1**if-else条件判断结构**](#2511if-else条件判断结构)
      - [**2.5.1.2.switch-case选择结构**](#2512switch-case选择结构)
    - [**2.5.2.循环结构**](#252循环结构)
      - [**2.5.2.1.循环结构的四要素**](#2521循环结构的四要素)
      - [**2.5.2.2.三种循环结构：**](#2522三种循环结构)
        - [**2.5.2.2.1 for循环结构**](#25221-for循环结构)
        - [**2.5.2.2.2 while循环结构**](#25222-while循环结构)
        - [**2.5.2.2.3  do-while循环结构**](#25223--do-while循环结构)
      - [**2.5.2.3.“无限循环”结构:**](#2523无限循环结构)
      - [**2.5.2.4.嵌套循环**](#2524嵌套循环)
    - [**2.5.3.break和continue**](#253break和continue)
    - [**2.5.4.Scanner类的使用**](#254scanner类的使用)
- [**3、数组**](#3数组)
  - [**3.1数组的概述**](#31数组的概述)
    - [**3.1.1.数组的理解：**](#311数组的理解)
    - [**3.1.2.数组相关的概念：**](#312数组相关的概念)
    - [**3.1.3.数组的特点：**](#313数组的特点)
    - [**3.1.4.数组的分类：**](#314数组的分类)
  - [**3.2.一维数组**](#32一维数组)
    - [**3.2.1.一维数组的声明与初始化**](#321一维数组的声明与初始化)
    - [**3.2.2.一维数组元素的引用：**](#322一维数组元素的引用)
    - [**3.2.3.数组的属性：length**](#323数组的属性length)
      - [**3.2.3.4.一维数组的遍历**](#3234一维数组的遍历)
      - [**3.2.3.5.一维数组元素的默认初始化值**](#3235一维数组元素的默认初始化值)
      - [**3.2.3.6.一维数组的内存解析**](#3236一维数组的内存解析)
  - [**3.3.二维数组**](#33二维数组)
    - [**3.3.1.如何理解二维数组？**](#331如何理解二维数组)
    - [**3.3.2.二维数组的声明与初始化**](#332二维数组的声明与初始化)
    - [**3.3.3.如何调用二维数组元素:**](#333如何调用二维数组元素)
    - [**3.3.4.二维数组的属性：**](#334二维数组的属性)
    - [**3.3.5.遍历二维数组元素**](#335遍历二维数组元素)
    - [**3.3.6.二维数组元素的默认初始化值**](#336二维数组元素的默认初始化值)
    - [**3.3.7.二维数组的内存结构**](#337二维数组的内存结构)
  - [**3.4.数组的常见算法**](#34数组的常见算法)
    - [**3.4.1.数组的创建与元素赋值：**](#341数组的创建与元素赋值)
    - [**3.4.2.针对于数值型的数组：**](#342针对于数值型的数组)
    - [**3.4.3.数组的赋值与复制**](#343数组的赋值与复制)
      - [**3.4.3.1 赋值：**](#3431-赋值)
      - [**3.4.3.2 复制：**](#3432-复制)
      - [**3.4.4.数组元素的反转**](#344数组元素的反转)
    - [**3.4.5.数组中指定元素的查找：搜索、检索**](#345数组中指定元素的查找搜索检索)
    - [**3.4.6.数组的排序算法**](#346数组的排序算法)
  - [**3.5.Arrays工具类的使用**](#35arrays工具类的使用)
    - [**3.5.1.理解：**](#351理解)
    - [**3.5.2.使用：**](#352使用)
  - [**3.6.数组的常见异常**](#36数组的常见异常)
    - [**3.6.1.数组角标越界异常：**](#361数组角标越界异常)
    - [**3.6.2.空指针异常：**](#362空指针异常)
- [**4、面向对象-上**](#4面向对象-上)
  - [**4.1.类与对象**](#41类与对象)
    - [**4.1.1.面向对象学习的三条主线：**](#411面向对象学习的三条主线)
    - [**4.1.2.面向对象与面向过程（理解）**](#412面向对象与面向过程理解)
      - [**4.1.2.1.面向过程**](#4121面向过程)
      - [**4.1.2.2.面向对象**](#4122面向对象)
      - [**4.1.2.3.完成一个项目（或功能）的思路：**](#4123完成一个项目或功能的思路)
      - [**4.1.2.4.面向对象中两个重要的概念：**](#4124面向对象中两个重要的概念)
      - [**4.1.2.6.对象的创建与对象的内存解析**](#4126对象的创建与对象的内存解析)
      - [**4.1.2.7.匿名对象:**](#4127匿名对象)
      - [**4.1.2.8.理解"万事万物皆对象"**](#4128理解万事万物皆对象)
  - [**4.2.JVM内存结构**](#42jvm内存结构)
  - [**4.3.类的结构之一：属性**](#43类的结构之一属性)
    - [**4.3.1.属性,局部变量相同点：**](#431属性局部变量相同点)
    - [**4.3.2.属性,局部变量不同点：**](#432属性局部变量不同点)
  - [**4.4.类的结构之二：方法**](#44类的结构之二方法)
    - [**4.4.1.举例：**](#441举例)
    - [**4.4.2.方法的声明：**](#442方法的声明)
    - [**4.4.3.说明：**](#443说明)
      - [**4.4.3.1 关于权限修饰符：**](#4431-关于权限修饰符)
      - [**4.4.3.2 返回值类型：**](#4432-返回值类型)
      - [**4.4.3.3 方法名：**](#4433-方法名)
      - [**4.4.3.4 形参列表：**](#4434-形参列表)
      - [**4.4.3.5 方法体：**](#4435-方法体)
    - [**4.4.4.方法的使用中，可以调用当前类的属性或方法**](#444方法的使用中可以调用当前类的属性或方法)
    - [**4.4.5.return关键字：**](#445return关键字)
    - [**4.4.5.方法的重载**](#445方法的重载)
      - [**4.4.5.3如何判断是否构成方法的重载？**](#4453如何判断是否构成方法的重载)
      - [**4.4.5.4.如何确定类中某一个方法的调用：**](#4454如何确定类中某一个方法的调用)
    - [**4.4.6.可变个数形参的方法**](#446可变个数形参的方法)
      - [**4.4.6.1.使用说明：**](#4461使用说明)
      - [**4.4.6.2.举例说明：**](#4462举例说明)
    - [**4.4.7.java的值传递机制**](#447java的值传递机制)
      - [4.4.7.1.针对于方法内变量的赋值举例：](#4471针对于方法内变量的赋值举例)
      - [**4.4.7.2.针对于方法的参数概念**](#4472针对于方法的参数概念)
      - [**4.4.7.3.java中参数传递机制：值传递**](#4473java中参数传递机制值传递)
      - [4.4.7.4.典型例题与内存解析：](#4474典型例题与内存解析)
    - [**4.4.8.递归方法**](#448递归方法)
      - [**4.4.8.1.定义：**](#4481定义)
      - [**4.4.8.2.如何理解递归方法？**](#4482如何理解递归方法)
      - [**4.4.8.3.举例：**](#4483举例)
  - [**4.5.面向对象的特征一：封装性**](#45面向对象的特征一封装性)
    - [**4.5.1.为什么要引入封装性？**](#451为什么要引入封装性)
    - [**4.5.2.问题引入：**](#452问题引入)
    - [**4.5.3.封装性思想具体的代码体现：**](#453封装性思想具体的代码体现)
    - [**4.5.4.Java规定的四种权限修饰符**](#454java规定的四种权限修饰符)
      - [**4.5.4 .1权限从小到大顺序为：**](#454-1权限从小到大顺序为)
      - [**4.5.4.2 具体的修饰范围：**](#4542-具体的修饰范围)
      - [**4.5.4.3权限修饰符可用来修饰的结构说明：**](#4543权限修饰符可用来修饰的结构说明)
  - [**4.6.类的结构之三：构造器**](#46类的结构之三构造器)
      - [**4.6.1.构造器（或构造方法）：Constructor**](#461构造器或构造方法constructor)
      - [**4.6.2.使用说明：**](#462使用说明)
      - [**4.6.3.举例：**](#463举例)
      - [**4.6.4.属性赋值顺序**](#464属性赋值顺序)
      - [**4.6.5.JavaBean的概念**](#465javabean的概念)
  - [**4.7.关键字：this**](#47关键字this)
    - [**4.7.2.this调用属性、方法：**](#472this调用属性方法)
    - [**4.7.3.this调用构造器：**](#473this调用构造器)
  - [**4.8.关键字：package/import**](#48关键字packageimport)
    - [**4.8.1.package的使用**](#481package的使用)
      - [**4.8.1.1 使用说明：**](#4811-使用说明)
      - [**4.8.1.2 举例：**](#4812-举例)
      - [**4.8.1.3 JDK中的主要包介绍：**](#4813-jdk中的主要包介绍)
    - [**4.8.2.import的使用：**](#482import的使用)
- [**5、面向对象-中**](#5面向对象-中)
  - [**5.1、面向对象的特征二：继承性**](#51面向对象的特征二继承性)
    - [**5.1.1.为什么要有类的继承性？(继承性的好处）**](#511为什么要有类的继承性继承性的好处)
    - [**5.1.2.继承性的格式：**](#512继承性的格式)
    - [**5.1.3.子类继承父类以后有哪些不同？**](#513子类继承父类以后有哪些不同)
    - [**5.1.4.Java中继承性的说明**](#514java中继承性的说明)
    - [**5.1.5.java.lang.Object类的理解**](#515javalangobject类的理解)
  - [**5.2.方法的重写**](#52方法的重写)
    - [**5.2.1.什么是方法的重写(override 或 overwrite)？**](#521什么是方法的重写override-或-overwrite)
    - [**5.2.2.应用：**](#522应用)
    - [**5.2.3.举例：**](#523举例)
    - [**5.2.4.重写的规则：**](#524重写的规则)
    - [**5.2.5.面试题：**](#525面试题)
  - [**5.3.关键字：super**](#53关键字super)
    - [**5.3.1.super 关键字可以理解为：父类的**](#531super-关键字可以理解为父类的)
    - [**5.3.2.可以用来调用的结构：**](#532可以用来调用的结构)
    - [**5.3.3.super调用属性、方法：**](#533super调用属性方法)
    - [**5.3.4.super调用构造器：**](#534super调用构造器)
  - [**5.4.子类对象实例化全过程**](#54子类对象实例化全过程)
    - [**5.4.1.从结果上看：**](#541从结果上看)
    - [**5.4.2.从过程上看：**](#542从过程上看)
    - [**5.4.3.强调说明：**](#543强调说明)
  - [**5.5.面向对象的特征三：多态性**](#55面向对象的特征三多态性)
    - [**5.5.1.多态性的理解：**](#551多态性的理解)
    - [**5.5.2.何为多态性：**](#552何为多态性)
    - [**5.5.3.多态性的使用：**](#553多态性的使用)
    - [**5.5.4.多态性的使用前提：**](#554多态性的使用前提)
    - [**5.5.5.多态性的应用举例：**](#555多态性的应用举例)
    - [**5.5.6.多态性使用的注意点：**](#556多态性使用的注意点)
    - [**5.5.7.关于向上转型与向下转型：**](#557关于向上转型与向下转型)
      - [**5.5.7.1 向上转型：多态**](#5571-向上转型多态)
      - [**5.5.7.2 向下转型：**](#5572-向下转型)
    - [**5.5.8.面试题：**](#558面试题)
      - [**5.5.8.1 谈谈你对多态性的理解？**](#5581-谈谈你对多态性的理解)
      - [**5.5.8.2 多态是编译时行为还是运行时行为？**](#5582-多态是编译时行为还是运行时行为)
  - [**5.6.Object类的使用**](#56object类的使用)
    - [**5.6.2.equals()方法**](#562equals方法)
      - [**5.6.2.1 equals()的使用：**](#5621-equals的使用)
      - [**5.6.2.2如何重写equals()**](#5622如何重写equals)
      - [**5.6.2.3.回顾 == 运算符的使用：**](#5623回顾--运算符的使用)
    - [**5.6.3.toString()方法**](#563tostring方法)
      - [**5.6.3.1 toString()的使用：**](#5631-tostring的使用)
      - [**5.6.3.2 如何重写toString()**](#5632-如何重写tostring)
    - [**5.6.4.面试题：**](#564面试题)
      - [**5.6.4.1 final、finally、finalize的区别？**](#5641-finalfinallyfinalize的区别)
      - [**5.6.4..2 == 和 equals() 区别**](#5642--和-equals-区别)
  - [**5.7、单元测试方法**](#57单元测试方法)
    - [**5.7.1.步骤：**](#571步骤)
    - [**5.7.2.说明：**](#572说明)
  - [**5.8.包装类的使用**](#58包装类的使用)
    - [**5.8.1.为什么要有包装类(或封装类）**](#581为什么要有包装类或封装类)
    - [**5.8.2.基本数据类型与对应的包装类：**](#582基本数据类型与对应的包装类)
    - [**5.8.3.需要掌握的类型间的转换：**](#583需要掌握的类型间的转换)
- [**6、面向对象-下**](#6面向对象-下)
  - [**6.1、关键字：static**](#61关键字static)
    - [**6.1.1.可以用来修饰的结构：**](#611可以用来修饰的结构)
      - [**6.1.1.2.static修饰属性：静态变量（或类变量）**](#6112static修饰属性静态变量或类变量)
        - [**6.1.1.2.1 属性，是否使用static修饰，**](#61121-属性是否使用static修饰)
        - [**6.1.1.2.2 static修饰属性的其他说明：**](#61122-static修饰属性的其他说明)
        - [6.1.1.2.3 静态属性举例：System.out; Math.PI;](#61123-静态属性举例systemout-mathpi)
      - [**6.1.1.3.静态变量内存解析：**](#6113静态变量内存解析)
      - [**6.1.1.4.static修饰方法：静态方法、类方法**](#6114static修饰方法静态方法类方法)
      - [**6.1.1.5.static的注意点：**](#6115static的注意点)
      - [**6.1.1.6.如何判定属性和方法应该使用static关键字：**](#6116如何判定属性和方法应该使用static关键字)
        - [**6.1.1.6.1 关于属性**](#61161-关于属性)
        - [**6.1.1.6.2 关于方法**](#61162-关于方法)
      - [**6.1.1.7.使用举例：**](#6117使用举例)
    - [**6.1.2.单例模式**](#612单例模式)
      - [**6.1.2.1.设计模式的说明**](#6121设计模式的说明)
        - [**6.1.2.1.1 理解**](#61211-理解)
        - [**6.1.2.1.2 常用设计模式**](#61212-常用设计模式)
      - [**6.1.2.2.单例模式**](#6122单例模式)
        - [**6.1.2.2.1 要解决的问题：**](#61221-要解决的问题)
        - [**6.1.2.2.2 具体代码的实现：**](#61222-具体代码的实现)
        - [**6.1.2.2.3 两种方式的对比：**](#61223-两种方式的对比)
  - [**6.2、main()的使用说明**](#62main的使用说明)
  - [**6.3、类的结构：代码块**](#63类的结构代码块)
    - [**6.3.1.代码块的作用：**](#631代码块的作用)
    - [**6.3.3.静态代码块：**](#633静态代码块)
    - [**6.3.4.非静态代码块：**](#634非静态代码块)
    - [**6.3.5.实例化子类对象时，**](#635实例化子类对象时)
    - [**6.3.6.属性的赋值顺序**](#636属性的赋值顺序)
  - [**6.4、关键字：final**](#64关键字final)
    - [**6.4.1.可以用来修饰：类、方法、变量**](#641可以用来修饰类方法变量)
    - [**6.4.2.具体的：**](#642具体的)
      - [**6.4.2.1 final 用来修饰一个类:**](#6421-final-用来修饰一个类)
      - [**6.4.2.2 final 用来修饰方法：**](#6422-final-用来修饰方法)
      - [**6.4.2.3 final 用来修饰变量：**](#6423-final-用来修饰变量)
  - [**6.5、关键字：abstract**](#65关键字abstract)
    - [**6.5.1.可以用来修饰：类、方法**](#651可以用来修饰类方法)
      - [**6.5.1.1.abstract修饰类：抽象类**](#6511abstract修饰类抽象类)
      - [**6.5.1.2.abstract修饰方法：抽象方法**](#6512abstract修饰方法抽象方法)
    - [**6.5.2.注意点：**](#652注意点)
    - [**6.5.3.abstract的应用举例：**](#653abstract的应用举例)
    - [**6.4.5.模板方法的设计模式**](#645模板方法的设计模式)
      - [**6.4.5.1.解决的问题**](#6451解决的问题)
      - [**6.4.5.2.举例**](#6452举例)
      - [**6.4.5.3.应用场景**](#6453应用场景)
  - [**6.6、关键字：interface**](#66关键字interface)
    - [**6.6.1.使用说明：**](#661使用说明)
    - [**6.6.2.举例：**](#662举例)
    - [**6.6.3.体会面向接口编程的思想**](#663体会面向接口编程的思想)
    - [**6.6.4.Java8中关于接口的新规范**](#664java8中关于接口的新规范)
    - [**6.6.5.接口面试题：**](#665接口面试题)
      - [**6.6.5.1.抽象类和接口的异同？**](#6651抽象类和接口的异同)
    - [**6.6.6.代理模式**](#666代理模式)
      - [**6.6.6.1.解决的问题**](#6661解决的问题)
      - [**6.6.6.2.举例**](#6662举例)
      - [**6.6.6.3.应用场景**](#6663应用场景)
    - [**6.6.7.工厂的设计模式**](#667工厂的设计模式)
      - [**6.6.7.1.解决的问题**](#6671解决的问题)
      - [**6.6.7.2.具体模式**](#6672具体模式)
  - [**6.7.类的结构：内部类**](#67类的结构内部类)
    - [**6.7.1.定义：**](#671定义)
    - [**6.7.2.内部类的分类：**](#672内部类的分类)
    - [**6.7.3.成员内部类的理解：**](#673成员内部类的理解)
    - [**6.7.4.成员内部类：**](#674成员内部类)
      - [**6.7.4.1如何创建成员内部类的对象？(静态的，非静态的)**](#6741如何创建成员内部类的对象静态的非静态的)
      - [**6.7.4.2如何在成员内部类中调用外部类的结构？**](#6742如何在成员内部类中调用外部类的结构)
    - [**6.7.5.局部内部类的使用：**](#675局部内部类的使用)
      - [**6.7.5.1.注意点：**](#6751注意点)
      - [**6.7.5.2.总结：**](#6752总结)

# **1、课程整体内容概述**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.001.png)

## **1.1、Java语言概述**

### **1.1.1、基础常识**

软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为：系统软件 和 应用软件	

系统软件：windows , mac os , linux ,unix,android,ios,....

应用软件：word ,ppt,画图板,...

人机交互方式： 图形化界面  vs  命令行方式

应用程序 = 算法 + 数据结构

**常用DOS命令：**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.002.png)

### **1.1.2.计算机语言的发展迭代史**

第一代：机器语言

第二代：汇编语言

第三代：高级语言

 面向过程：C,Pascal、Fortran

 面向对象：Java,JS,Python,Scala,...

### **1.1.3.Java语言版本迭代概述**

1991年 Green项目，开发语言最初命名为Oak (橡树)

1994年，开发组意识到Oak 非常适合于互联网

1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作

1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最

1998年，发布JDK 1.2，同年发布企业平台J2EE

1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生

2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0

2005年，J2SE -> JavaSE，J2EE -> JavaEE，J2ME -> JavaME

2009年，Oracle公司收购SUN，交易价格74亿美元

2011年，发布JDK 7.0

2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本

2017年，发布JDK 9.0，最大限度实现模块化

2018年3月，发布JDK 10.0，版本号也称为18.3

2018年9月，发布JDK 11.0，版本号也称为18.9

### **1.1.4.Java语言应用的领域：**

Java Web开发：后台开发

大数据开发：

Android应用程序开发：客户端开发

### **1.1.5.Java语言的特点**

 面向对象性：

两个要素：类、对象

三个特征：封装、继承、多态

 健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 -->仍然会出现内存溢出、内存泄漏

 跨平台型：write once,run anywhere:一次编译，到处运行

功劳归功于：JVM

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.003.png)

## **1.2、开发环境搭建**

### **1.2.1 JDK、JRE、JVM的关系**


![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.004.png)

### **1.2.2 JDK的下载、安装**

下载：官网，github

安装：傻瓜式安装：JDK 、JRE

`   `注意问题：安装软件的路径中不能包含中文、空格。

### **1.2.3 path环境变量的配置**

- **为什么配置path环境变量？**

path环境变量：windows操作系统执行命令时所要搜寻的路径

为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。

- **如何配置**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.005.png)

## **1.3、第一个Java程序**

### **1.3.1.开发体验——HelloWorld**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.006.png)

- **编写创建一个 java 源文件：**

HelloWorld.java

```java
class HelloChina{ public static void main(String[] args)
    System.out.println("Hello,World!"); 
} 
```
- **编译**：

```java
javac HelloWorld.java
```

- **运行**：

```java
java HelloChina
```

### **1.3.2.常见问题的解决**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.007.png)

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.008.png)

### **1.3.3.总结第一个程序**

- 1.java程序编写-编译-运行的过程

 编写：我们将编写的java代码保存在以".java"结尾的源文件中

 编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java

 运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名

- 2.在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。
   而且要求声明为public的类的类名必须与源文件名相同。

- 3.程序的入口是main()方法。格式是固定的。

- 4.输出语句：
   System.out.println():先输出数据，然后换行
   System.out.print():只输出数据

- 5.每一行执行语句都以";"结束。

- 6.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。

## **1.4、注释与API文档等**

### **1.4.1.注释:Comment**

**分类：**

单行注释：//

多行注释：/*    /

文档注释：/\*\*    \*/

**作用：**

① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人

② 调试所写的代码

**特点：**

①单行注释和多行注释，注释了的内容不参与编译。

 换句话说，编译以后生成的.class结尾的字节码文件中不包含注释掉的信息

② 注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。

③ 多行注释不可以嵌套使用

### **1.4.2.Java API 文档：**　

API:application programming interface。习惯上：将语言提供的类库，都称为api.

API文档：针对于提供的类库如何使用，给的一个说明书。类似于《新华字典》

### **1.4.3.良好的编程风格**

# **2、基础语法**

## **2.1、关键字与标识符**

### **2.1.1.java关键字的使用**

定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）

特点：关键字中所字母都为小写

具体哪些关键字：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.009.png)

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.010.png)

### **2.1.2.保留字：**

- 现Java版本尚未使用，但以后版本可能会作为关键字使用。
- 具体哪些保留字：goto 、const
- 注意：自己命名标识符时要避免使用这些保留字

### **2.1.3.标识符的使用**

- 定义：凡是自己可以起名字的地方都叫标识符。
   涉及到的结构：
- 包名、类名、接口名、变量名、方法名、常量名

 **规则：(必须要遵守。否则，编译不通过)**

 规范：（可以不遵守，不影响编译和运行。但是要求大家遵守）

- 注意点：
   在起名字时，为了提高阅读性，要尽量意义，“见名知意”。

## **2.2、变量的使用(重点)**
### **2.2.1.变量的分类**
- #### **按数据类型分类**
  - ##### **整型：**
    - **byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)**
       ① byte范围：-128 ~ 127
       ② 声明long型变量，必须以"l"或"L"结尾
       ③ 通常，定义整型变量时，使用int型。
       ④整型的常量，默认类型是：int型

  - #####  浮点型：
    - **float(4字节) \ double(8字节)**
       ① 浮点型，表示带小数点的数值
       ② float表示数值的范围比long还大
       ③ 定义float类型变量时，变量要以"f"或"F"结尾
       ④ 通常，定义浮点型变量时，使用double型。
       ⑤ 浮点型的常量，默认类型为：double

  - ##### **字符型：**
    **char (1字符=2字节)**
    ① 定义char型变量，通常使用一对'',内部只能写一个字符
    ② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量

  - ##### **布尔型：**
    - **boolean**
       //① 只能取两个值之一：true 、 false
       //② 常常在条件判断、循环结构中使用

- **按声明的位置分类(了解)**

### 2.2.2.定义变量的格式：**

- 数据类型  变量名 = 变量值;
   或
- 数据类型  变量名;
- 变量名 = 变量值;

### **2.2.3.变量使用的注意点：**

 ① 变量必须先声明，后使用

 ② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了

 ③ 同一个作用域内，不可以声明两个同名的变量

### **2.2.4.基本数据类型变量间运算规则**

### **2.2.5 涉及到的基本数据类型：**

除了boolean之外的其他7种

- **自动类型转换**

  (只涉及7种基本数据类型）

  结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。

   byte 、char 、short --> int --> long --> float --> double 

   特别的：当byte、char、short三种类型的变量做运算时，结果为int型

  说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量

- **强制类型转换**

  (只涉及7种基本数据类型）：

  自动类型提升运算的逆运算。

  - 1.需要使用强转符：()
  - 2.注意点：强制类型转换，可能导致精度损失。

- **String与8种基本数据类型间的运算**
  - String属于引用数据类型,翻译为：字符串

  - 声明String类型变量时，使用一对""

  - String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+

  - 运算的结果仍然是String类型
    避免：

  ```java
  String s = 123;//编译错误
  String s1 = "123";
  int i = (int)s1;//编译错误
  ```

## **2.3、进制(了解)**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.011.png)

### **2.3.1.编程中涉及的进制及表示方式：**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.012.png)

### **2.3.2.二进制的使用说明：**

- **计算机底层的存储方式：**

所有数字在计算机底层都以二进制形式存在。

- **二进制数据的存储方式：**

所有的数值，不管正负，底层都以补码的方式存储。

- **原码、反码、补码的说明：**
  - 正数：三码合一
  - 负数：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.013.png)

- **进制间的转换：**
  
  **图示**
  ![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.012.png)
  
  **图示二进制转换为十进制：**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.014.png)

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.015.png)

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.016.png)

**图示十进制转换为二进制：**
![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.017.png)
**二进制与八进制、十六进制间的转换：**
![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.018.png)
![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.019.png)

## **2.4、运算符**

### **2.4.1.算术运算符：**

**+，-，\* ，/ ，% ，(前)++， (后)++， (前)--， (后)-- +** 

- **【典型代码】**

```java
//除号：/
int num1 = 12;
int num2 = 5;
int result1 = num1 / num2;
System.out.println(result1);//2
// %:取余运算
//结果的符号与被模数的符号相同
//开发中，经常使用%来判断能否被除尽的情况。
int m1 = 12;
int n1 = 5;
System.out.println("m1 % n1 = " + m1 % n1);
int m2 = -12;
int n2 = 5;
System.out.println("m2 % n2 = " + m2 % n2);
int m3 = 12;
int n3 = -5;
System.out.println("m3 % n3 = " + m3 % n3);
int m4 = -12;
int n4 = -5;
System.out.println("m4 % n4 = " + m4 % n4);
//(前)++ :先自增1，后运算
//(后)++ :先运算，后自增1
int a1 = 10;
int b1 = ++a1;
System.out.println("a1 = " + a1 + ",b1 = " + b1);
int a2 = 10;
int b2 = a2++;
System.out.println("a2 = " + a2 + ",b2 = " + b2);
int a3 = 10;
++a3;//a3++;
int b3 = a3;
//(前)-- :先自减1，后运算
//(后)-- :先运算，后自减1
int a4 = 10;
int b4 = a4--;//int b4 = --a4;
System.out.println("a4 = " + a4 + ",b4 = " + b4);
```

- **【特别说明】**
  - 1.//(前)++ :先自增1，后运算
     //(后)++ :先运算，后自增1
  - 2.//(前)-- :先自减1，后运算
     //(后)-- :先运算，后自减1
  - 3.连接符：+：只能使用在String与其他数据类型变量之间使用。

### **2.4.2.赋值运算符**

**= , +=,  -=  ,\*= , /=  ,%=** 

- **【典型代码】**

```java
int i2,j2;//连续赋值i2 = j2 = 10;
//
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*int i3 = 10,j3 = 20;
int num1 = 10;
num1 += 2;
//num1 = num1 + 2;
System.out.println(num1);//12	
int num2 = 12;
num2 %= 5;
//num2 = num2 % 5;
System.out.println(num2);
short s1 = 10;
//s1 = s1 + 2;//编译失败
s1 += 2;//结论：不会改变变量本身的数据类型System.out.println(s1);
```

- **【特别说明】**

1.运算的结果不会改变变量本身的数据类型

```java
//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)
//方式一：num = num + 2;
//方式二：num += 2; (推荐)	
//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)
//方式一：num = num + 1;
//方式二：num += 1; 
//方式三：num++; (推荐)
```



### **2.4.3.比较运算符（关系运算符）**

```java
==， != ，>  ，<  ，>=，  <= ， instanceof
```

- **【典型代码】**

```java
int i = 10;
int j = 20;
System.out.println(i == j);//false
System.out.println(i = j);//20
boolean b1 = true;
boolean b2 = false;
System.out.println(b2 == b1);//false
System.out.println(b2 = b1);//true
```

- **【特别说明】**

1.比较运算符的结果是boolean类型
2.>  <  >=  <= :只能使用在数值类型的数据之间。

3.== 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。

```java
Account acct1 = new Account(1000);
Account acct2 = new Account(1000);
boolean b1 = (acct1 == acct2);//比较两个Account是否是同一个账户。
boolean b2 = (acct1 != acct2);//
```



### **2.4.4.逻辑运算符**

```java
& ，&& ， | ，|| ，! ， ^
```

- **【典型代码】**

```java
//区分& 与 &&
//相同点1：& 与  && 的运算结果相同
//相同点2：当符号左边是true时，二者都会执行符号右边的运算
//不同点：当符号左边是false时，&继续执行符号右边的运算。&&不再执行符号右边的运算。
//开发中，推荐使用&&
boolean b1 = true;
b1 = false;
int num1 = 10;
if(b1 & (num1++ > 0)){
	System.out.println("我现在在北京");
}else{
	System.out.println("我现在在南京");
}
System.out.println("num1 = " + num1);
boolean b2 = true;
b2 = false;
int num2 = 10;
if(b2 && (num2++ > 0)){
	System.out.println("我现在在北京");
}else{
	System.out.println("我现在在南京");
}
System.out.println("num2 = " + num2);

// 区分：| 与 || 
//相同点1：| 与  || 的运算结果相同
//相同点2：当符号左边是false时，二者都会执行符号右边的运算
//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算
//开发中，推荐使用||
boolean b3 = false;
b3 = true;
int num3 = 10;
if(b3 | (num3++ > 0)){
	System.out.println("我现在在北京");
}else{
	System.out.println("我现在在南京");
}
System.out.println("num3 = " + num3);
boolean b4 = false;
b4 = true;
int num4 = 10;
if(b4 || (num4++ > 0)){
	System.out.println("我现在在北京");
}else{
	System.out.println("我现在在南京");
}
	System.out.println("num4 = " + num4);
```

- **【特别说明】**

1.逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型

### **2.4.5.位运算符：**
```java
<<  ,>> ,>>> ,&  ,|,  ^,  ~
```

- **【典型代码】**

```java
int i = 21;
i = -21;
System.out.println("i << 2 :" + (i << 2));
System.out.println("i << 3 :" + (i << 3));
System.out.println("i << 27 :" + (i << 27));
int i = 21;
i = -21;
System.out.println("i << 2 :" + (i << 2));
System.out.println("i << 3 :" + (i << 3));
System.out.println("i << 27 :" + (i << 27));
int m = 12;
int n = 5;
System.out.println("m & n :" + (m & n));
System.out.println("m | n :" + (m | n));
System.out.println("m ^ n :" + (m ^ n));
```

- **【面试题】**

   你能否写出最高效的2 \* 8的实现方式？ 

  答案：2 << 3  或  8 << 1

- **【特别说明】**
  - 位运算符操作的都是整型的数据
  - '<<'：在一定范围内，每向左移1位，相当于 \* 2
  - '>>':在一定范围内，每向右移1位，相当于 / 2

- **典型题目：**
  - 1.交换两个变量的值。
  - 2.实现60的二进制到十六进制的转换

### **2.4.6.三元运算符**

**(条件表达式)? 表达式1 : 表达式2**

- **【典型代码】**
  - 1.获取两个整数的较大值
  - 2.获取三个数的最大值

- **【特别说明】**
  - ① 条件表达式的结果为boolean类型

  - ② 根据条件表达式真或假，决定执行表达式1，还是表达式2.
     如果表达式为true，则执行表达式1。
     如果表达式为false，则执行表达式2。

  - ③ 表达式1 和表达式2要求是一致的。

  - ④ 三元运算符可以嵌套使用

      凡是可以使用三元运算符的地方，都可以改写为if-else

      反之，不成立。

- 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。

## **2.5.流程控制**

### **2.5.1分支结构**

#### 2.5.1.1**if-else条件判断结构**

- **结构一：只有一个**

```java
if(条件表达式){
	//执行表达式
}
```


  - **结构二：二选一**

```java
if(条件表达式){
	//执行表达式1
}else{
	//执行表达式2
}
```
  - **结构三：n选一**

```java
if(条件表达式){
	//执行表达式1
}else if(条件表达式){
	//执行表达式2
}else if(条件表达式){
	//执行表达式3
}
//...
else{
	//执行表达式n
}
```
- ##### **说明：**
  - else 结构是可选的。
  - 针对于条件表达式：
   如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。   > 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。   > 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。

  - if-else结构是可以相互嵌套的。
  
  - 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。

#### **2.5.1.2.switch-case选择结构**
```java
switch(表达式){
	case 常量1:
        //执行语句1;
        break;
	case 常量2:
        //执行语句2;
        break;
		//...
	default:
        //执行语句n;
        break;
}
```

**2.5.1.2.1.说明：**

① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。

② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构

③ switch结构中的表达式，只能是如下的6种数据类型之一：

 byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)

④ case 之后只能声明常量。不能声明范围。

⑤ break关键字是可选的。

⑥ default:相当于if-else结构中的else.  

 default结构是可选的，而且位置是灵活的。

⑥如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。

⑥break在switch-case中是可选的

### **2.5.2.循环结构**

#### **2.5.2.1.循环结构的四要素**

① 初始化条件

② 循环条件  --->是boolean类型

③ 循环体

④ 迭代条件

说明：通常情况下，循环结束都是因为②中循环条件返回false了。

#### **2.5.2.2.三种循环结构：**

##### **2.5.2.2.1 for循环结构**

```java
for(1;2;4){
	3
}
```

执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②

##### **2.5.2.2.2 while循环结构**
```java
1
while(2){
	3
	4
}
```
执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②

**说明：**

写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！

**for和while循环总结：**

1. 开发中，基本上我们都会从for、while中进行选择，实现循环结构。
1. for循环和while循环是可以相互转换的！
    区别：for循环和while循环的初始化条件部分的作用范围不同。
1. 我们写程序，要避免出现死循环。

##### **2.5.2.2.3  do-while循环结构**
```java
1
do{
    3
    4
}while(2);
```

**执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②**

- **说明：**
   1.do-while循环至少会执行一次循环体！
   2.开发中，使用for和while更多一些。较少使用do-while

#### **2.5.2.3.“无限循环”结构:**

- **while(true) 或 for(;;)**
   总结：如何结束一个循环结构？
   方式一：当循环条件是false时
   方式二：在循环体中，执行break

#### **2.5.2.4.嵌套循环**

- 嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环
  内层循环：循环结构A
  外层循环：循环结构B

- 说明：
  ① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次
  ② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m \* n次
  ③ 外层循环控制行数，内层循环控制列数

- 典型练习
  //练习一：

```java
for(int j = 1;j <= 4;j++ ){
    for(int i = 1;i <= 6;i++){
        System.out.print('\*');
    }
    System.out.println();
}
```

​		//练习二：

```java
/\*			i(行号)		j(\*的个数)
\*			1			1
\*\*			2			2
\*\*\*			3			3
\*\*\*\*		4			4
\*\*\*\*\*		5			5
\*/
for(int i = 1;i <= 5;i++){//控制行数
    for(int j = 1;j <= i;j++){//控制列数
        System.out.print("\*");	
    }
	System.out.println();
}
```

 //练习三：九九乘法表

 //练习四：100以内的质数

- **补充:衡量一个功能代码的优劣：**
  - 正确性
  - 可读性
  - 健壮性
  - 高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）

如何理解流程控制的练习：

流程控制结构的使用 + 算法逻辑

### **2.5.3.break和continue**

**break和continue关键字的使用**

 					使用范围		循环中使用的作用(不同点)		相同点

break:		switch-case			

 循环结构中		结束当前循环					关键字后面不能声明执行语句	

continue:		循环结构中		结束当次循环					关键字后面不能声明执行语句

**补充：带标签的break和continue的使用**

**return在方法中讲。**

### **2.5.4.Scanner类的使用**

**如何从键盘获取不同类型的变量：需要使用Scanner类**

- **具体实现步骤：**
   1.导包：import java.util.Scanner;
   2.Scanner的实例化:Scanner scan = new Scanner(System.in);
   3.调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量

- **注意：**
   需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException
   导致程序终止。

```java
//1.导包：import java.util.Scanner;
import java.util.Scanner;
class ScannerTest{
    public static void main(String[] args){
        //2.Scanner的实例化
        Scanner scan = new Scanner(System.in);
        //3.调用Scanner类的相关方法
        System.out.println("请输入你的姓名：");
        String name = scan.next();
        System.out.println(name);
        System.out.println("请输入你的芳龄：");
        int age = scan.nextInt();
        System.out.println(age);
        System.out.println("请输入你的体重：");
        double weight = scan.nextDouble();
        System.out.println(weight);
        System.out.println("你是否相中我了呢？(true/false)");
        boolean isLove = scan.nextBoolean();
        System.out.println(isLove);
        //对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串
        System.out.println("请输入你的性别：(男/女)");
        String gender = scan.next();//"男"
        char genderChar = gender.charAt(0);//获取索引为0位置上的字符
        System.out.println(genderChar);	
    }
}
```

# **3、数组**

## **3.1数组的概述**

### **3.1.1.数组的理解：**

数组(Array)，是多个相同类型数据一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。

### **3.1.2.数组相关的概念：**

- 数组名
- 元素
- 角标、下标、索引
- 数组的长度：元素的个数

### **3.1.3.数组的特点：**

- 1数组是序排列的
- 2数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型
- 3创建数组对象会在内存中开辟一整块连续的空间
- 4数组的长度一旦确定，就不能修改。

### **3.1.4.数组的分类：**

- ① 照维数：

 ​	一维数组、二维数组、。。。

- ② 照数组元素的类型：

 ​	基本数据类型元素的数组、引用数据类型元素的数组

**数据结构：**

**1.数据与数据之间的逻辑关系：**

​	集合、一对一、一对多、多对多

**2.数据的存储结构：**

​	**线性表：**顺序表（比如：数组）、链表、栈、队列

​	**树形结构：**二叉树

​	**图形结构：**

**算法：**

 排序算法：

 搜索算法：

## **3.2.一维数组**

### **3.2.1.一维数组的声明与初始化**

**正确的方式：**

```java
int num;//声明
num = 10;//初始化
int id = 1001;//声明 + 初始化
int[] ids;//声明
//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行
ids = new int[]{1001,1002,1003,1004};
//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行
String[] names = new String[5];
int[] arr4 = {1,2,3,4,5};//类型推断
```

**错误的方式：**

//		int[] arr1 = new int[];

//		int[5] arr2 = new int[5];

//		int[] arr3 = new int[3]{1,2,3};

### **3.2.2.一维数组元素的引用：**

​	**通过角标的方式调用。**

```java
//数组的角标（或索引从0开始的，到数组的长度-1结束。
names[0] = "王铭";
names[1] = "王赫";
names[2] = "张学良";
names[3] = "孙居龙";
names[4] = "王宏志";//charAt(0)
```



### **3.2.3.数组的属性：length**

```java
System.out.println(names.length);//5
System.out.println(ids.length);
```



- **说明：**
   数组一旦初始化，其长度就是确定的。arr.length
   数组长度一旦确定，就不可修改。\*

#### **3.2.3.4.一维数组的遍历**

```java
for(int i = 0;i < names.length;i++){
	System.out.println(names[i]);
}
```

#### **3.2.3.5.一维数组元素的默认初始化值**

- 数组元素是整型：0
- 数组元素是浮点型：0.0
- 数组元素是char型：0或'\u0000'，而非'0'
- 数组元素是boolean型：false
- 数组元素是引用数据类型：null

#### **3.2.3.6.一维数组的内存解析**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.020.png)

## **3.3.二维数组**

### **3.3.1.如何理解二维数组？**

数组属于引用数据类型

数组的元素也可以是引用数据类型

一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。

### **3.3.2.二维数组的声明与初始化**

**正确的方式：**

```java
int[] arr = new int[]{1,2,3};//一维数组
//静态初始化
int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};
//动态初始化1
String[][] arr2 = new String[3][2];
//动态初始化2
String[][] arr3 = new String[3][];
//也是正确的写法：
int[] arr4[] = new int[][]{{1,2,3},{4,5,9,10},{6,7,8}};
int[] arr5[] = {{1,2,3},{4,5},{6,7,8}};//类型推断
```

**错误的方式：**

```java
//		String[][] arr4 = new String[][4];
//		String[4][3] arr5 = new String[][];
//		int[][] arr6 = new int[4][3]{{1,2,3},{4,5},{6,7,8}};
```

### **3.3.3.如何调用二维数组元素:**

```java
System.out.println(arr1[0][1]);//2
System.out.println(arr2[1][1]);//nullarr3[1] = new String[4];
System.out.println(arr3[1][0]);
System.out.println(arr3[0])
```

### **3.3.4.二维数组的属性：**

```java
System.out.println(arr4.length);//3
System.out.println(arr4[0].length);//3
System.out.println(arr4[1].length);//4
```

### **3.3.5.遍历二维数组元素**

```java
for(int i = 0;i < arr4.length;i++){
    for(int j = 0;j < arr4[i].length;j++){
    	System.out.print(arr4[i][j] + "  ");
    }
    System.out.println();
}
```



### **3.3.6.二维数组元素的默认初始化值**

规定：二维数组分为外层数组的元素，内层数组的元素

​	int[] [] arr = new int[4] [3];

​	外层元素：arr[0] [1]等

​	内层元素：arr[0] [0],arr[1] [2]等

 **数组元素的默认初始化值** 

- 针对于初始化方式一：比如：int arr = new int4;

 ​		外层元素的初始化值为：地址值

 ​		内层元素的初始化值为：与一维数组初始化情况相同

- 针对于初始化方式二：比如：int arr = new int4;

 ​		外层元素的初始化值为：null

 ​		内层元素的初始化值为：不能调用，否则报错。

### **3.3.7.二维数组的内存结构**



## **3.4.数组的常见算法**

### **3.4.1.数组的创建与元素赋值：**

杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。

### **3.4.2.针对于数值型的数组：**

最大值、最小值、总和、平均数等

### **3.4.3.数组的赋值与复制**

```java
int[] array1,array2;
array1 = new int[]{1,2,3,4};
```

#### **3.4.3.1 赋值：**

```java
array2 = array1;
```


如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。

#### **3.4.3.2 复制：**

```java
array2 = new int[array1.length];

for(int i = 0;i < array2.length;i++){

array2[i] = array1[i];

}
```

如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。

#### **3.4.4.数组元素的反转**

```java
//方法一：
 for(int i = 0;i < arr.length / 2;i++){
     String temp = arr[i];
     arr[i] = arr[arr.length - i -1];
     arr[arr.length - i -1] = temp;
 }

//方法二：
 for(int i = 0,j = arr.length - 1;i < j;i++,j--){
     String temp = arr[i];
     arr[i] = arr[j];
     arr[j] = temp;
 }
```

### **3.4.5.数组中指定元素的查找：搜索、检索**

- **线性查找：**

实现思路：通过遍历的方式，一个一个的数据进行比较、查找。

适用性：具有普遍适用性。

- **二分法查找：**

实现思路：每次比较中间值，折半的方式检索。

适用性：（前提：数组必须有序）

### **3.4.6.数组的排序算法**

**理解：**

- 衡量排序算法的优劣：
   时间复杂度、空间复杂度、稳定性

-  排序的分类：内部排序 与 外部排序（需要借助于磁盘）


- 不同排序算法的时间复杂度


- 手写冒泡排序

```java
int[] arr = new int[]{43,32,76,-98,0,64,33,-21,32,99};	
 //冒泡排序
 for(int i = 0;i < arr.length - 1;i++){		
     for(int j = 0;j < arr.length - 1 - i;j++){			
         if(arr[j] > arr[j + 1]){
             int temp = arr[j];
             arr[j] = arr[j + 1];
             arr[j + 1] = temp;
         }
     }		
 }	
```

## **3.5.Arrays工具类的使用**

### **3.5.1.理解：**

① 定义在java.util包下。

② Arrays:提供了很多操作数组的方法。

### **3.5.2.使用：**

```java
//1.boolean equals(int[] a,int[] b):判断两个数组是否相等。
 int[] arr1 = new int[]{1,2,3,4};
 int[] arr2 = new int[]{1,3,2,4};
 boolean isEquals = Arrays.equals(arr1, arr2);
 System.out.println(isEquals);

 //2.String toString(int[] a):输出数组信息。
 System.out.println(Arrays.toString(arr1));

 //3.void fill(int[] a,int val):将指定值填充到数组之中。
 Arrays.fill(arr1,10);
 System.out.println(Arrays.toString(arr1));

 //4.void sort(int[] a):对数组进行排序。
 Arrays.sort(arr2);
 System.out.println(Arrays.toString(arr2));

 //5.int binarySearch(int[] a,int key)
 int[] arr3 = new int[]{-98,-34,2,34,54,66,79,105,210,333};
 int index = Arrays.binarySearch(arr3, 210);
 if(index >= 0){
 	System.out.println(index);
 }else{
 	System.out.println("未找到");
 }
```

## **3.6.数组的常见异常**

### **3.6.1.数组角标越界异常：**

- **ArrayIndexOutOfBoundsException**

```java
int[] arr = new int[]{1,2,3,4,5};
//		for(int i = 0;i <= arr.length;i++){
//			System.out.println(arr[i]);
//		}
//		System.out.println(arr[-2]);
//		System.out.println("hello");
```

### **3.6.2.空指针异常：**

- **NullPointerException**

```java
//情况一：
//		int[] arr1 = new int[]{1,2,3};
//		arr1 = null;
//		System.out.println(arr1[0]);
 //情况二：
//		int[][] arr2 = new int[4][];
//		System.out.println(arr2[0][0]);
 //情况三：
 String[] arr3 = new String[]{"AA","BB","CC"};
 arr3[0] = null;
 System.out.println(arr3[0].toString());	
```

小知识：一旦程序出现异常，未处理时，就终止执行。

# **4、面向对象-上**

## **4.1.类与对象**

### **4.1.1.面向对象学习的三条主线：**

- **Java类及类的成员：**
  - **属性、方法、构造器；代码块、内部类**

- **面向对象的大特征：**
  - **封装性、继承性、多态性、(抽象性)**

- **其它关键字：**
  - **this、super、static、final、abstract、interface、package、import等**

**“大处着眼，小处着手”**

### **4.1.2.面向对象与面向过程（理解）**

#### **4.1.2.1.面向过程**

强调的是功能行为，以函数为最小单位，考虑怎么做。

#### **4.1.2.2.面向对象**

强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

举例对比：人把大象装进冰箱。

#### **4.1.2.3.完成一个项目（或功能）的思路：**

#### **4.1.2.4.面向对象中两个重要的概念：**

- **类**：对一类事物的描述，是抽象的、概念上的定义

- **对象**：是实际存在的该类事物的每个个体，因而也称为实例(instance)

 ​		面向对象程序设计的重点是类的设计

 ​		**设计类，就是设计类的成员。**

**二者的关系：**

**对象，是由类new出来的，派生出来的。**

**4.1.2.5.面向对象思想落地实现的规则一**

- 1.创建类，设计类的成员
- 2.创建类的对象
- 3.通过“对象.属性”或“对象.方法”调用对象的结构

补充：几个概念的使用说明

- 属性 = 成员变量 = field = 域、字段
- 方法 = 成员方法 = 函数 = method
- 创建类的对象 = 类的实例化 = 实例化类

#### **4.1.2.6.对象的创建与对象的内存解析**

典型代码：

```java
Person p1 = new Person();
Person p2 = new Person();
Person p3 = p1;//没有新创建一个对象，共用一个堆空间中的对象实体。
```

说明：

如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）

意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。

内存解析：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.021.png)

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.022.png)

#### **4.1.2.7.匿名对象:**

**我们创建的对象，没显式的赋给一个变量名。即为匿名对象**

特点：**匿名对象只能调用一次。**

举例：

```java
new Phone().sendEmail();
new Phone().playGame();
new Phone().price = 1999;
new Phone().showPrice();//0.0

//应用场景：
PhoneMall mall = new PhoneMall();
//匿名对象的使用
mall.show(new Phone());
class PhoneMall{
    public void show(Phone phone){
        phone.sendEmail();
        phone.playGame();
    }
}
```



#### **4.1.2.8.理解"万事万物皆对象"**

1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构

- Scanner,String等
- 文件：File
- 网络资源：URL

2.涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。

## **4.2.JVM内存结构**

编译完源程序以后，生成一个或多个字节码文件。

我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。

《JVM规范》

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.023.png)

**虚拟机栈，**即为平时提到的栈结构。我们将局部变量存储在栈结构中

**堆，**我们将new出来的结构（比如：数组、对象）加载在对空间中。补充：对象的属性（非static的）加载在堆空间中。

**方法区**：类的加载信息、常量池、静态域

## **4.3.类的结构之一：属性**

类的设计中，两个重要结构之一：属性

### **4.3.1.属性,局部变量相同点：**

- 1.1  定义变量的格式：数据类型  变量名 = 变量值
- 1.2 先声明，后使用
- 1.3 变量都其对应的作用域

### **4.3.2.属性,局部变量不同点：**

**在类中声明的位置的不同**

-  **属性**：直接定义在类的一对{}内

-  **局部变量**：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量

**关于权限修饰符的不同**

- **属性**：可以在声明属性时，指明其权限，使用权限修饰符。
​		常用的权限修饰符：private、public、缺省、protected  --->封装性
​		目前，大家声明属性时，都使用缺省就可以了。
- **局部变量**：不可以使用权限修饰符。

**默认初始化值的情况**：

-  **属性**：类的属性，根据其类型，都默认初始化值。
   ​		整型（byte、short、int、long：0）
   ​		浮点型（float、double：0.0）
   ​		字符型（char：0  （或'\u0000'））
   ​		布尔型（boolean：false）
   ​		引用数据类型（类、数组、接口：null）
-  **局部变量**：没默认初始化值。
   ​	意味着，我们在调用局部变量之前，一定要显式赋值。特别地：形参在调用时，我们赋值即可。

**在内存中加载的位置：**

- **属性**：加载到堆空间中   （非static）

- **局部变量**：加载到栈空间

**补充：回顾变量的分类：**

 方式一：按照数据类型：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.024.png)


​	方式二：按照在类中声明的位置：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.025.png)

## **4.4.类的结构之二：方法**

 **方法：描述类应该具的功能。**

比如：Math类：sqrt()\random() ...

Scanner类：nextXxx() ...

Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ...

### **4.4.1.举例：**

```java
public void eat(){}
public void sleep(int hour){}
public String getName(){}
public String getNation(String nation){}
```

### **4.4.2.方法的声明：**

```java
权限修饰符  返回值类型  方法名(形参列表){
	方法体
}
```

注意：static、final、abstract 来修饰的方法，后面再讲。

### **4.4.3.说明：**

#### **4.4.3.1 关于权限修饰符：**

​		默认方法的权限修饰符先都使用public

​		Java规定的4种权限修饰符：private、public、缺省、protected  -->封装性再细说

#### **4.4.3.2 返回值类型：**

​	 **返回值  vs 没返回值**

- 如果方法返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return				关键字返回指定类型的变量或常量：“return 数据”。


- 如果方法没返回值，则方法声明时，使用void来表示。通常，没返回值的方法中，就不需要使用return.				但是，如果使用的话，只能“return;”表示结束此方法的意思。


- 我们定义方法该不该返回值？
  ​						① 题目要求
  ​						② 凭经验：具体问题具体分析

#### **4.4.3.3 方法名：**

​			**属于标识符，遵循标识符的规则和规范，“见名知意”**

#### **4.4.3.4 形参列表：**

- **方法可以声明0个，1个，或多个形参。**
  - 格式：数据类型1 形参1,数据类型2 形参2,...
  - 我们定义方法时，该不该定义形参？

​						① 题目要求

​						② 凭经验：具体问题具体分析

#### **4.4.3.5 方法体：**

​			方法功能的体现。 	

### **4.4.4.方法的使用中，可以调用当前类的属性或方法**

​		特殊的：方法A中又调用了方法A:递归方法。

​		方法中，不可以定义方法。

### **4.4.5.return关键字：**

​	1.使用范围：使用在方法体中

​	2.作用：

​			① 结束方法

​			② 针对于返回值类型的方法，使用"return 数据"方法返回所要的数据。

​	3.注意点：return关键字后面不可以声明执行语句。

### **4.4.5.方法的重载**

- **方法的重载的概念**
  - 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
  - 总结："两同一不同":同一个类、相同方法名
  -  参数列表不同：参数个数不同，参数类型不同

- **是否构成重载：**

  - 构成重载举例一：

    ​	Arrays类中重载的sort() / binarySearch()；

    ​	PrintStream中的println()

  - 构成重载举例二：

```java
//如下的4个方法构成了重载
public void getSum(int i,int j){
	System.out.println("1");
}
public void getSum(double d1,double d2){
	System.out.println("2");
}

public void getSum(String s ,int i){
	System.out.println("3");
}

public void getSum(int i,String s){
	System.out.println("4");
}
```

不构成重载的举例：

//如下的3个方法不能与上述4个方法构成重载

```java
//	public int getSum(int i,int j){
//		return 0;
//	}
//	public void getSum(int m,int n){
//		
//	}
//	private void getSum(int i,int j){
//		
//	}
```

#### **4.4.5.3如何判断是否构成方法的重载？**

严格按照定义判断：**两同一不同**。

 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！

#### **4.4.5.4.如何确定类中某一个方法的调用：**

方法名 ---> 参数列表

**面试题：**

方法的重载与重写的区别？

throws\throw的区别

String\StringBuffer\StringBuilder的区别

Collection\Collections的区别

final\finally\finalize的区别

...

抽象类、接口的区别

sleep() / wait()的区别

### **4.4.6.可变个数形参的方法**

#### **4.4.6.1.使用说明：**

- 1.jdk 5.0新增的内容
- 2.具体使用：
- 2.1 可变个数形参的格式：数据类型 ... 变量名
- 2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。
- 2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
- 2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。
- 2.5 可变个数形参在方法的形参中，必须声明在末尾
- 2.6  可变个数形参在方法的形参中,最多只能声明一个可变形参。

#### **4.4.6.2.举例说明：**

```java
public void show(int i){
}
public void show(String s){
 System.out.println("show(String)");
}

public void show(String ... strs){
 System.out.println("show(String ... strs)");
 for(int i = 0;i < strs.length;i++){
 System.out.println(strs[i]);
 }
}

//不能与上一个方法同时存在
//	public void show(String[] strs){
//		
//	}

//调用时：
 test.show("hello");
 test.show("hello","world");
 test.show();
 test.show(new String[]{"AA","BB","CC"});
```

### **4.4.7.java的值传递机制**

#### 4.4.7.1.针对于方法内变量的赋值举例：

```java
System.out.println("\*\*\*\*\*\*\*\*\*\*\*基本数据类型：\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*");
 int m = 10;
 int n = m;
 System.out.println("m = " + m + ", n = " + n);
 n = 20;
 System.out.println("m = " + m + ", n = " + n);
 System.out.println("\*\*\*\*\*\*\*\*\*\*\*引用数据类型：\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*");
 Order o1 = new Order();
 o1.orderId = 1001;
 Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。
 System.out.println("o1.orderId = " + o1.orderId + ",o2.orderId = " +o2.orderId);
 o2.orderId = 1002;
 System.out.println("o1.orderId = " + o1.orderId + ",o2.orderId = " +o2.orderId);
```

**规则**：

 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。

 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

#### **4.4.7.2.针对于方法的参数概念**

​	**形参**：方法定义时，声明的小括号内的参数

​	**实参**：方法调用时，实际传递给形参的数据

#### **4.4.7.3.java中参数传递机制：值传递**

**规则**：

​	如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。

​	如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。

**推广**：

 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。

 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

#### 4.4.7.4.典型例题与内存解析：

【例题1】

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.026.png)


【例题2】

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.027.png)

### **4.4.8.递归方法**

#### **4.4.8.1.定义：**

递归方法：一个方法体内调用它自身。

#### **4.4.8.2.如何理解递归方法？**

方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。

递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

#### **4.4.8.3.举例：**

```java
// 例1：计算1-n之间所自然数的和
public int getSum(int n) {// 3
     if (n == 1) {
     	return 1;
     } else {
     	return n + getSum(n - 1);
     }
}

// 例2：计算1-n之间所自然数的乘积:n!
public int getSum1(int n) {
 if (n == 1) {
 return 1;
 } else {
 return n \* getSum1(n - 1);
 }
}
```



//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2\*f(n+1) + f(n),

//其中n是大于0的整数，求f(10)的值。

```java
public int f(int n){
     if(n == 0){
     	return 1;
     }else if(n == 1){
    	 return 4;
     }else{
     	//return f(n + 2) - 2 \* f(n + 1);
         return 2\*f(n - 1) + f(n - 2);
     }
}       
```

//例4：斐波那契数列

//例5：汉诺塔问题

//例6：快排

## **4.5.面向对象的特征一：封装性**

​		**面向对象的特征一：封装与隐藏**

### **4.5.1.为什么要引入封装性？**

我们程序设计追求“高内聚，低耦合”。

 **高内聚** ：类的内部数据操作细节自己完成，不允许外部干涉；

 **低耦合** ：仅对外暴露少量的方法用于使用。

隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，**把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想**。

### **4.5.2.问题引入：**

当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private).

` 		 `-->此时，针对于属性就体现了封装性。

### **4.5.3.封装性思想具体的代码体现：**

​	体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值

```java
private double radius;
public void setRadius(double radius){
 	this.radius = radius;
}
public double getRadius(){
 	return radius;
}
```

​	体现二：不对外暴露的私有的方法

​	体现三：单例模式（将构造器私有化）

​	体现四：如果不希望类在包外被调用，可以将类设置为缺省的。

### **4.5.4.Java规定的四种权限修饰符**

#### **4.5.4 .1权限从小到大顺序为：**

​		private <  缺省 < protected < public

#### **4.5.4.2 具体的修饰范围：**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.028.png)

#### **4.5.4.3权限修饰符可用来修饰的结构说明：**

​		4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类

​		修饰类的话，只能使用：缺省、public

## **4.6.类的结构之三：构造器**

#### **4.6.1.构造器（或构造方法）：Constructor**

构造器的作用：

- 1.创建对象
- 2.初始化对象的信息

#### **4.6.2.使用说明：**

- 1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器
- 2.定义构造器的格式：权限修饰符  类名(形参列表){}
- 3.一个类中定义的多个构造器，彼此构成重载
- 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
- 5.一个类中，至少会有一个构造器。

#### **4.6.3.举例：**

```java
//构造器
public Person(){
	 System.out.println("Person().....");
}
public Person(String n){
	 name = n;
}
public Person(String n,int a){
     name = n;
     age = a;
}
```



#### **4.6.4.属性赋值顺序**

总结：属性赋值的先后顺序

​		① 默认初始化

​		② 显式初始化

​		③ 构造器中初始化

​		④ 通过"对象.方法" 或 "对象.属性"的方式，赋值

以上操作的先后顺序：① - ② - ③ - ④  

#### **4.6.5.JavaBean的概念**

​	**所谓JavaBean，是指符合如下标准的Java类：**

​			类是公共的

​			一个无参的公共的构造器

​			属性，且对应的get、set方法

## **4.7.关键字：this**

**4.7.1.可以调用的结构：**

​					属性、方法；构造器

### **4.7.2.this调用属性、方法：**

**this理解为：当前对象  或 当前正在创建的对象**

- **在类的方法中，**

  我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，

  通常情况下，我们都择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式

  的使用"this.变量"的方式，表明此变量是属性，而非形参。

- **在类的构造器中**，

  我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

### **4.7.3.this调用构造器：**

① 我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器

② 构造器中不能通过"this(形参列表)"方式调用自己

③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"

④ 规定："this(形参列表)"必须声明在当前构造器的首行

⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

## **4.8.关键字：package/import**

### **4.8.1.package的使用**

#### **4.8.1.1 使用说明：**

- 1.为了更好的实现项目中类的管理，提供包的概念
- 2.使用package声明类或接口所属的包，声明在源文件的首行
- 3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”
- 4.每"."一次，就代表一层文件目录。

#### **4.8.1.2 举例：**

举例一：某航运软件系统包括：一组域对象、GUI和reports子系统

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.029.png)

举例二：MVC设计模式

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.030.png)

#### **4.8.1.3 JDK中的主要包介绍：**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.031.png)

### **4.8.2.import的使用：**

**import:导入**

- 在源文件中显式的使用import结构导入指定包下的类、接口
- 声明在包的声明和类的声明之间
- 如果需要导入多个结构，则并列写出即可
- 可以使用"xxx.\*"的方式，表示可以导入xxx包下的所结构
- 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
- 如果使用的类或接口是本包下定义的，则可以省略import结构
- 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。
- 使用"xxx.\*"方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入
- import static:导入指定类或接口中的静态结构:属性或方法。

# **5、面向对象-中**

## **5.1、面向对象的特征二：继承性**

### **5.1.1.为什么要有类的继承性？(继承性的好处）**

- ① 减少了代码的冗余，提高了代码的复用性
- ② 便于功能的扩展
- ③ 为之后多态性的使用，提供了前提
  图示：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.032.png)

### **5.1.2.继承性的格式：**

class A extends B{}

- A:子类、派生类、subclass
- B:父类、超类、基类、superclass

### **5.1.3.子类继承父类以后有哪些不同？**

- 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。

​			特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。

-  子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。

​			子类和父类的关系，不同于子集和集合的关系。

​			extends：延展、扩展

### **5.1.4.Java中继承性的说明**

- 一个类可以被多个子类继承。
- Java中类的单继承性：一个类只能有一个父类
- 子父类是相对的概念。
- 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
- 子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法

图示：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.033.png)

### **5.1.5.java.lang.Object类的理解**

- 如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类
- 所的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类
- 意味着，所的java类具有java.lang.Object类声明的功能。

## **5.2.方法的重写**

### **5.2.1.什么是方法的重写(override 或 overwrite)？**

子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.

### **5.2.2.应用：**

重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

### **5.2.3.举例：**

```java
class Circle{
	public double findArea(){}//求面积
}

class Cylinder extends Circle{
	public double findArea(){}//求表面积
}

class Account{
	public boolean withdraw(double amt){}
}

class CheckAccount extends Account{
	public boolean withdraw(double amt){}
}
```



### **5.2.4.重写的规则：**

```java
方法的声明  权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
	//方法体
}
```

约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符

​	特殊情况：子类不能重写父类中声明为private权限的方法

③ 返回值类型：

​	父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void

​	父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类

​	父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)

④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）

​	子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。	

### **5.2.5.面试题：**

区分方法的重写和重载？

答：① 二者的概念：

② 重载和重写的具体规则

③ 重载：不表现为多态性。重写：表现为多态性。

重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。

所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；

而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 

引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”

## **5.3.关键字：super**

### **5.3.1.super 关键字可以理解为：父类的**

### **5.3.2.可以用来调用的结构：**

​	属性、方法、构造器

### **5.3.3.super调用属性、方法：**

-  我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
-  特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
- 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。

### **5.3.4.super调用构造器：**

-  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
-  "super(形参列表)"的使用，必须声明在子类构造器的首行！
- 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二一，不能同时出现
- 在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
- 在类的多个构造器中，至少一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

## **5.4.子类对象实例化全过程**

理解即可。

### **5.4.1.从结果上看：**

**继承性**

​	子类继承父类以后，就获取了父类中声明的属性或方法。

​	创建子类的对象，在堆空间中，就会加载所父类中声明的属性。

### **5.4.2.从过程上看：**

当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。

图示：

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.034.png)

### **5.4.3.强调说明：**

虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.035.png)

## **5.5.面向对象的特征三：多态性**

### **5.5.1.多态性的理解：**

​	可以理解为一个事物的多种形态。

### **5.5.2.何为多态性：**

​	对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

​	举例：

```java
Person p = new Man();
Object obj = new Date();
```

### **5.5.3.多态性的使用：**

​	虚拟方法调用

​	有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

​	总结：编译，看左边；运行，看右边。

### **5.5.4.多态性的使用前提：**

① 类的继承关系  ② 方法的重写

### **5.5.5.多态性的应用举例：**

举例一：

```java
public void func(Animal animal){//Animal animal = new Dog();
     animal.eat();
     animal.shout();
}
```

举例二：

```java
public void method(Object obj){
}
```

举例三：

```java
class Driver{
     public void doData(Connection conn){
         //conn = new MySQlConnection(); 
         // conn = new  OracleConnection();
         //规范的步骤去操作数据
         //conn.method1();
         //conn.method2();
         //conn.method3();
     }     
}  
```

### **5.5.6.多态性使用的注意点：**

​	对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

### **5.5.7.关于向上转型与向下转型：**

#### **5.5.7.1 向上转型：多态**

#### **5.5.7.2 向下转型：**

- ##### 为什么使用向下转型：

  有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。

- ##### 如何实现向下转型：

  使用强制类型转换符：()

- ##### 使用时的注意点：

  ① 使用强转时，可能出现ClassCastException的异常。

  ② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。

- #####  instanceof的使用：

  ① a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。

  ② 如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。

  ③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。

- #####  图示：


![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.036.png)

### **5.5.8.面试题：**

#### **5.5.8.1 谈谈你对多态性的理解？**

① 实现代码的通用性。	

② Object类中定义的public boolean equals(Object obj){  }

​	 JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)

③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）

#### **5.5.8.2 多态是编译时行为还是运行时行为？**

## **5.6.Object类的使用**

**5.6.1.java.lang.Object类的说明：**

- Object类是所Java类的根父类
- 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
- Object类中的功能(属性、方法)就具通用性。
  - 属性：无
  - 方法：equals()、 toString() 、 getClass() 、hashCode()clone() 、finalize()、wait() 、 notify()、notifyAll()
- Object类只声明了一个空参的构造器

### **5.6.2.equals()方法**

#### **5.6.2.1 equals()的使用：**

- 1. 是一个方法，而非运算符
- 2. 只能适用于引用数据类型
- 3. Object类中equals()的定义：

```java
public boolean equals(Object obj) {
	return (this == obj);
}
```

​	说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

- 4. 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。
- 5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同.

#### **5.6.2.2如何重写equals()**

- **手动重写举例：**

```java
class User{
    String name;
    int age;
    //重写其equals()方法
    public boolean equals(Object obj){
     if(obj == this){
     return true;
     }
     if(obj instanceof User){
     User u = (User)obj;
     return this.age == u.age && this.name.equals(u.name);
     }
     return false;
    }
}
```

- **开发中如何实现：自动生成的**

#### **5.6.2.3.回顾 == 运算符的使用：**

**== ：运算符**

- 5.6.2.3.1.可以使用在基本数据类型变量和引用数据类型变量中
- 5.6.2.3.2.如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）

 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。

### **5.6.3.toString()方法**

#### **5.6.3.1 toString()的使用：**

- 5.6.3.1.1当我们输出一个对象的引用时，实际上就是调用当前对象的toString()
- 5.6.3.1.2.Object类中toString()的定义：

```java
public String toString() {
 return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

- 5.6.3.1.3.像String、Date、File、包装类等都重写了Object类中的toString()方法。

  使得在调用对象的toString()时，返回"实体内容"信息
- 5.6.3.1.4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"

#### **5.6.3.2 如何重写toString()**

举例：

```java
//自动实现
@Override
public String toString() {
	return "Customer [name=" + name + ", age=" + age + "]";
}
```

### **5.6.4.面试题：**

#### **5.6.4.1 final、finally、finalize的区别？**

#### **5.6.4..2 == 和 equals() 区别**

## **5.7、单元测试方法**

**Java中的JUnit单元测试**

### **5.7.1.步骤：**

- 5.7.1.1.中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步
- 5.7.1.2.创建Java类，进行单元测试。

  此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器

- 5.7.1.3.此类中声明单元测试方法。

  此时的单元测试方法：方法的权限是public,没返回值，没形参

- 5.7.1.4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;
- 5.7.1.5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。
- 5.7.1.6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test

### **5.7.2.说明：**

- 5.7.2.1.如果执行结果没任何异常：绿条
- 5.7.2.2.如果执行结果出现异常：红条

## **5.8.包装类的使用**

![图片](C:\Users\HymesZhao\Desktop\java____1\imgs\https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.037.png)

### **5.8.1.为什么要有包装类(或封装类）**

为了使基本数据类型的变量具有类的特征，引入包装类。

### **5.8.2.基本数据类型与对应的包装类：**

### **5.8.3.需要掌握的类型间的转换：**

**（基本数据类型、包装类、String）**

![图片](C:\Users\HymesZhao\Desktop\java____1\imgs\https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.038.png)

**简易版：**

基本数据类型<--->包装类：J**DK 5.0 新特性：自动装箱 与自动拆箱**

基本数据类型、包装类--->String:**调用String重载的valueOf(Xxx xxx)**

String--->基本数据类型、包装类:**调用包装类的parseXxx(String s)**

 注意：转换时，可能会报NumberFormatException

**应用场景举例：**

① Vector类中关于添加元素，只定义了形参为Object类型的方法：

v.addElement(Object obj);   //基本数据类型 --->包装类 --->使用多态





# **6、面向对象-下**

## **6.1、关键字：static**

**static:静态的**

### **6.1.1.可以用来修饰的结构：**

主要用来修饰类的内部结构

属性、方法、代码块、内部类

#### **6.1.1.2.static修饰属性：静态变量（或类变量）**

##### **6.1.1.2.1 属性，是否使用static修饰，**

又分为：**静态属性  vs 非静态属性(实例变量)**

**实例变量**：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。

**静态变量**：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。

##### **6.1.1.2.2 static修饰属性的其他说明：**

① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用

② 静态变量的加载要早于对象的创建。

③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。

④		类变量	实例变量

类		yes		no

对象	yes		yes

##### 6.1.1.2.3 静态属性举例：System.out; Math.PI;

#### **6.1.1.3.静态变量内存解析：**

![图片](C:\Users\HymesZhao\Desktop\java____1\imgs\https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.039.png)

#### **6.1.1.4.static修饰方法：静态方法、类方法**

① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

② 静态方法	非静态方法

- 类		    yes		no

- 对象		yes		yes

③ 静态方法中，只能调用静态的方法或属性
   非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

#### **6.1.1.5.static的注意点：**

- 6.1.1.5.1 在静态的方法内，不能使用this关键字、super关键字
- 6.1.1.5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。

#### **6.1.1.6.如何判定属性和方法应该使用static关键字：**

##### **6.1.1.6.1 关于属性**

	属性是可以被多个对象所共享的，不会随着对象的不同而不同的。类中的常量也常常声明为static

##### **6.1.1.6.2 关于方法**

操作静态属性的方法，通常设置为static的

工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections

#### **6.1.1.7.使用举例：**

- 举例一：Arrays、Math、Collections等工具类
- 举例二：单例模式
- 举例三：

```java
class Circle{
    private double radius;
    private int id;//自动赋值
    public Circle(){
     id = init++;
     total++;
    }
    public Circle(double radius){
     this();
    //		id = init++;
    //		total++;
     this.radius = radius;
    }
    private static int total;//记录创建的圆的个数
    private static int init = 1001;//static声明的属性被所对象所共享
    public double findArea(){
     return 3.14 \* radius \* radius;
    }
    public double getRadius() {
     return radius;
    }
    public void setRadius(double radius) {
     this.radius = radius;
    }
    public int getId() {
     return id;
    }
    public static int getTotal() {
     return total;
}
}
```

### **6.1.2.单例模式**

#### **6.1.2.1.设计模式的说明**

##### **6.1.2.1.1 理解**

设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。

##### **6.1.2.1.2 常用设计模式**

- **23种经典的设计模式  GOF**
   **创建型模式，共5种**：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 
   **结构型模式，共7种**：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 
   **行为型模式，共11种**：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 

#### **6.1.2.2.单例模式**

##### **6.1.2.2.1 要解决的问题：**

​	所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。

##### **6.1.2.2.2 具体代码的实现：**

**饿汉式1：**

```java
class Bank{
    //1.私化类的构造器
    private Bank(){	
    }
    //2.内部创建类的对象
    //4.要求此对象也必须声明为静态的
    private static Bank instance = new Bank();
    //3.提供公共的静态的方法，返回类的对象
    public static Bank getInstance(){
     return instance;
    }
}
```

**饿汉式2：使用了静态代码块**

```java
class Order{
    //1.私化类的构造器
    private Order(){
    }
    //2.声明当前类对象，没初始化
    //4.此对象也必须声明为static的
    private static Order instance = null;
    static{
     instance = new Order();
    }
    //3.声明public、static的返回当前类对象的方法
    public static Order getInstance(){
     return instance;
    }
}
```

**懒汉式：**

```java
class Order{
	//1.私化类的构造器
    private Order(){	
    }
    //2.声明当前类对象，没初始化
    //4.此对象也必须声明为static的
    private static Order instance = null;
    //3.声明public、static的返回当前类对象的方法
    public static Order getInstance(){
        if(instance == null){	
        instance = new Order();	
    	}
    return instance;
    }
}
```



##### **6.1.2.2.3 两种方式的对比：**

**饿汉式：**	

坏处：对象加载时间过长。

好处：饿汉式是线程安全的

**懒汉式：**

好处：延迟对象的创建。

坏处（目前的写法）：线程不安全。--->到多线程内容时，再修改

## **6.2、main()的使用说明**

- 1. main()方法作为程序的入口
- 2. main()方法也是一个普通的静态方法
- 3. main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）

**如何将控制台获取的数据传给形参：String[] args?**

 运行时：java 类名 "Tom" "Jerry" "123" "true"

```java
sysout(args[0]);//"Tom"
sysout(args[3]);//"true"  -->Boolean.parseBoolean(args[3]);
sysout(args[4]);//报异常
public static void main(String[] args){
	//方法体
}
```

- 权限修饰符：private 缺省 protected pubilc ---->封装性
- 修饰符：static \ final \ abstract \native 可以用来修饰方法
- 返回值类型： 无返回值 / 有返回值 -->return
- 方法名：需要满足标识符命名的规则、规范；"见名知意"
- 形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性
- 方法体：来体现方法的功能

```java
main(){
    Person p = new Man();
    p.eat();
    //p.earnMoney();
    Man man = new Man();
    man.eat();
    man.earnMoney();
}
```



## **6.3、类的结构：代码块**

类的成员之四：代码块(初始化块)（重要性较属性、方法、构造器差一些）

### **6.3.1.代码块的作用：**

用来初始化类、对象的信息

6.3.2.分类：

代码块要是使用修饰符，只能使用static

分类：静态代码块  vs 非静态代码块

### **6.3.3.静态代码块：**

内部可以输出语句

随着类的加载而执行,而且只执行一次

作用：初始化类的信息

如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行

静态代码块的执行要优先于非静态代码块的执行

静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构

### **6.3.4.非静态代码块：**

内部可以输出语句

随着对象的创建而执行

每创建一个对象，就执行一次非静态代码块

作用：可以在创建对象时，对对象的属性等进行初始化

如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行

非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法

### **6.3.5.实例化子类对象时，**

涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：

对应的练习：LeafTest.java / Son.java

由父及子，静态先行。

### **6.3.6.属性的赋值顺序**

①默认初始化

②显式初始化/⑤在代码块中赋值

③构造器中初始化

④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值

**执行的先后顺序：① - ② / ⑤ - ③ - ④**

## **6.4、关键字：final**

final：最终的

### **6.4.1.可以用来修饰：类、方法、变量**

### **6.4.2.具体的：**

#### **6.4.2.1 final 用来修饰一个类:**

​	此类不能被其他类所继承。

​	比如：String类、System类、StringBuffer类

#### **6.4.2.2 final 用来修饰方法：**

​	表明此方法不可以被重写

​	比如：Object类中getClass();

#### **6.4.2.3 final 用来修饰变量：**

​	此时的"变量"就称为是一个常量

- ##### **final修饰属性：**


​	可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化

- ##### **final修饰局部变量：**


​	尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。

**static final 用来修饰属性：全局常量**

## **6.5、关键字：abstract**

abstract: 抽象的

### **6.5.1.可以用来修饰：类、方法**

#### **6.5.1.1.abstract修饰类：抽象类**

- 此类不能实例化
- 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）
- 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 --->抽象的使用前提：继承性

#### **6.5.1.2.abstract修饰方法：抽象方法**

- 抽象方法只方法的声明，没方法体
- 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。
- 若子类重写了父类中的所的抽象方法后，此子类方可实例化
- 若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

### **6.5.2.注意点：**

- abstract不能用来修饰：属性、构造器等结构
- abstract不能用来修饰私方法、静态方法、final的方法、final的类

### **6.5.3.abstract的应用举例：**

**举例一：**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.040.png)

**举例二：**

```java
abstract class GeometricObject{
    public abstract double findArea();
    }
	class Circle extends GeometricObject{
        private double radius;
        public double findArea(){
            return 3.14 \* radius \* radius;
        };
	}
}
```

**举例三：**

IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部

定义了抽象的read()、write()方法。

### **6.4.5.模板方法的设计模式**

#### **6.4.5.1.解决的问题**

在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变

部分可以抽象出来，供不同子类实现。这就是一种模板模式。

#### **6.4.5.2.举例**

```java
abstract class Template{
    //计算某段代码执行所需要花费的时间
    public void spendTime(){
        long start = System.currentTimeMillis();
        this.code();//不确定的部分、易变的部分
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start));
    }
    public abstract void code();
}

class SubTemplate extends Template{
 	@Override
    public void code() {
         for(int i = 2;i <= 1000;i++){
             boolean isFlag = true;
             for(int j = 2;j <= Math.sqrt(i);j++){
                 if(i % j == 0){
                 isFlag = false;
                 break;
            }
         }
         if(isFlag){
            System.out.println(i);
         }
    }
}
```



#### **6.4.5.3.应用场景**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.041.png)

## **6.6、关键字：interface**

interface:接口

### **6.6.1.使用说明：**

- 1.接口使用interface来定义

- 2.Java中，接口和类是并列的两个结构

- 3.如何定义接口：**定义接口中的成员**

 **3.1 JDK7及以前**：只能定义全局常量和抽象方法

 ​		全局常量：public static final的.但是书写时，可以省略不写

 ​		抽象方法：public abstract的

 **3.2 JDK8**：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略

- 4.接口中不能定义构造器的！意味着接口不可以实例化

- 5.Java开发中，接口通过让类去实现(implements)的方式来使用.

 ​	如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化

 ​	如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类

- 6.Java类可以实现多个接口   --->弥补了Java单继承性的局限性

 ​	格式：class AA extends BB implements CC,DD,EE

- 7.接口与接口之间可以继承，而且可以多继承

- 8.接口的具体使用，体现多态性

- 9.接口，实际上可以看做是一种规范

### **6.6.2.举例：**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.042.png)	

```java
class Computer{
    public void transferData(USB usb){//USB usb = new Flash();
     usb.start();
     System.out.println("具体传输数据的细节");
     usb.stop();
    }
}

interface USB{
 //常量：定义了长、宽、最大最小的传输速度等
 void start();
 void stop();
}

class Flash implements USB{
 @Override
 public void start() {
 System.out.println("U盘开启工作");
 }
 @Override
 public void stop() {
 System.out.println("U盘结束工作");
 }
}

class Printer implements USB{
 @Override
 public void start() {
 System.out.println("打印机开启工作");
 }
 @Override
 public void stop() {
 System.out.println("打印机结束工作");
 }
}
```

**体会：**

- 1.接口使用上也满足多态性
- 2.接口，实际上就是定义了一种规范
- 3.开发中，体会面向接口编程！

### **6.6.3.体会面向接口编程的思想**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.043.png)

面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个

数据库厂商的API。

### **6.6.4.Java8中关于接口的新规范**

- //知识点1：接口中定义的静态方法，只能通过接口来调用。
- //知识点2：通过实现类的对象，可以调用接口中的默认方法。
  `      `//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
- //知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写        此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则
- //知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，
  `      `//那么在实现类没重写此方法的情况下，报错。-->接口冲突。
   //这就需要我们必须在实现类中重写此方法
- //知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法

```java
public void myMethod(){
 method3();//调用自己定义的重写的方法
 super.method3();//调用的是父类中声明的
 //调用接口中的默认方法
 CompareA.super.method3();
 CompareB.super.method3();
 }
```



### **6.6.5.接口面试题：**

#### **6.6.5.1.抽象类和接口的异同？**

- 相同点：

不能实例化；都可以包含抽象方法的。

- 不同点：
   1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明
   2）类：单继承性    接口：多继承
   类与接口：多实现

### **6.6.6.代理模式**

#### **6.6.6.1.解决的问题**

代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 

#### **6.6.6.2.举例**

```java
interface NetWork{
 	public void browse();
}

//被代理类
class Server implements NetWork{
	@Override
    public void browse() {
        System.out.println("真实的服务器访问网络");
    }
}

//代理类
class ProxyServer implements NetWork{
    private NetWork work;
    public ProxyServer(NetWork work){
    	this.work = work;
    }
    public void check(){
        System.out.println("联网之前的检查工作");
    }
 	@Override
    public void browse() {
        check();
        work.browse();	
    }
}
```



#### **6.6.6.3.应用场景**

![图片](https://github.com/HymesZhao/StudyNotes/blob/master/JavaJunior/JavaJuniorPic/Aspose.Words.0f4e9a31-5457-4a5c-86c0-9fd3c4e16363.044.png)

### **6.6.7.工厂的设计模式**

#### **6.6.7.1.解决的问题**

​	实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。

#### **6.6.7.2.具体模式**

**简单工厂模式**：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）

**工厂方法模式**：用来生产同一等级结构中的固定产品。（支持增加任意产品)

**抽象工厂模式**：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)

## **6.7.类的结构：内部类**

内部类：类的第五个成员

### **6.7.1.定义：**

Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.

### **6.7.2.内部类的分类：**

成员内部类（静态、非静态 ） vs 局部内部类(方法内、代码块内、构造器内)

### **6.7.3.成员内部类的理解：**

- 一方面，作为外部类的成员：
  - ​	调用外部类的结构

  - ​	可以被static修饰
  - ​	可以被4种不同的权限修饰
  
- 另一方面，作为一个类：
  - ​	类内可以定义属性、方法、构造器等
  - ​	可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
  - ​	可以被abstract修饰

### **6.7.4.成员内部类：**

#### **6.7.4.1如何创建成员内部类的对象？(静态的，非静态的)**

```java
//创建静态的Dog内部类的实例(静态的成员内部类):
Person.Dog dog = new Person.Dog();
//创建非静态的Bird内部类的实例(非静态的成员内部类):
//Person.Bird bird = new Person.Bird();//错误的
Person p = new Person();
Person.Bird bird = p.new Bird();
```



#### **6.7.4.2如何在成员内部类中调用外部类的结构？**

```java
class Person{
 String name = "小明";
    public void eat(){
    }
//非静态成员内部类
 class Bird{
 String name = "杜鹃";
 public void display(String name){
 System.out.println(name);//方法的形参
 System.out.println(this.name);//内部类的属性
 System.out.println(Person.this.name);//外部类的属性
 //Person.this.eat();
 }
 }
}
```



### **6.7.5.局部内部类的使用：**

```java
//返回一个实现了Comparable接口的类的对象
 public Comparable getComparable(){
 //创建一个实现了Comparable接口的类:局部内部类
 //方式一：
 //		class MyComparable implements Comparable{
//
//			@Override
//			public int compareTo(Object o) {
//				return 0;
//			}
//			
//		}
//		
//		return new MyComparable();
 //方式二：
 return new Comparable(){
 @Override
 public int compareTo(Object o) {
 return 0;
 }
 };
}	
```



#### **6.7.5.1.注意点：**

​	在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。

​	jdk 7及之前版本：要求此局部变量显式的声明为final的

​	jdk 8及之后的版本：可以省略final的声明

#### **6.7.5.2.总结：**

​	成员内部类和局部内部类，在编译以后，都会生成字节码文件。

​	格式：成员内部类：外部类$内部类名.class

​	 局部内部类：外部类$数字 内部类名.class
